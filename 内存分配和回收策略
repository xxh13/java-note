 对象的内存分配，其实就是在堆上分配内存，对象主要分配在新生代上的Eden区，如果启动了本地线程分配缓冲，将安线程优先在TLAB上分配。少数情况下
 也可能会直接分配在老年代中，分配的规则并不是固定的，其细节取决于当前使用的是哪一种垃圾收集器的组合，还有虚拟机和内存相关参数的配置。
 
 1. 对象优先分配在Eden分配区
    大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC(新生代GC：指的是发生在新生代的垃圾
    收集动作，因为Java对象大都都具备朝生夕死饿特性，所以Minor GC非常频繁，一般回收速度比较快)。
    
 2. 大对象直接进入老年代
    大对象是指需要大量连续空间内存的java对象，大对象对于虚拟机的内存分配来说就是一个坏消息(比遇到一个大对象更加坏的消息就是遇倒一群朝生
    夕死的短生命周期的对象，写程序的时候应当避免)，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的内存空间来安置
    这些大对象。
    虚拟机提供了一个-XX:PretenureSizeThreshold参数(PretenureSizeThreshold参数支队Serial和Parnew收集器有效)，令大于这个设置值的对象直接
    在老年代分配，这样做的目的是避免在Eden区以及两个Survivor区之间发生大量的内存复制(新生代采用复制算法收集内存)
    
 3. 长期存活的对象将进入老年代
    既然虚拟机采用了分代收集的思想来管理内存，那么回收内存时就必须能识别哪些对象应该放在新生代，哪些对象应该放在老年代中。为了做到这点，
    虚拟机给每个对象定义了一个对象计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survvor
    空间中，并且对象年龄设为1.对象在Survivor区中每"熬过"一次Minor GC,年龄就增加一岁，当他的年龄增加到一定程度(默认是15岁)，就将会被晋升
    到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。
    
 4. 动态对象年龄判断
    为了更好地适应不同程序的内存状况，虚拟机并不是永远地哟球对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中
    相同年龄所有对象大小的总和大于Survivor的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中年龄的要求
    
 5. 空间分配担保
    在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全
    的，如果不成立，则虚拟机会查看HandkePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的的连续空间是否
    大于历次晋升到老年代对象的平均大小，如果是，则进行一次Minor GC，尽管这次的Minor GC是有风险的，如果小于，或者HandlePromotionFailure
    不逊于冒险，那这是也要还未进行一次Full GC(老年代的GC，速度比Minor GC慢十倍以上)
    
