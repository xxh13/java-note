HotSpot垃圾收集器分类
  注：直到现在为止，还没有最好的收集器出现，也没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。
  
  1. Serial收集器(JDK1.3之前的新生代收集器，单线程)
     Serial收集器在进行垃圾回收时，必须暂停其他的工作线程，直到收集结束。这项工作实际上是由虚拟机在后台自发动发起和自动完成的。
     到现在为止，Serial收集器是虚拟机运行在client模式下的默认新生代收集器。
     
  2. ParNew收集器
     ParNew收集器其实就是Serial收集器的多线程版本，和Serial收集器公用了相当多的代码。ParNew收集器是许多运行在Server模式下的虚拟机中首选
     的新生代收集器。只有PerNew收集器和Serial收集器能够和CMS收集器配合工作。
     
  3. Parallel Scavenge 收集器
     Parallel Scavenge收集器是一个新生代收集器，并且使用复制算法和多线程。主要目标是达到一个可控制的吞吐量(CPU运行用户代码的时间与
     CPU总消耗时间的比值)。Parallel Scavenge收集器提供2个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的参数直接设置
     吞吐量大小的参数。
     
  4. Serial Old 收集器
     Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用"标记-整理"算法，主要给Cilent模式下的虚拟机使用。
     如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK1.5之前的把嫩中与Parallel Scavenge收集器搭配使用，另一种用途
     是作为CMS收集器的后备预案。
  
  5. Parallel Old收集器
     Parallel Old是ParallelScavenge收集器的老年代版本，使用多线程和"标记-整理"算法。在注重吞吐量和CPU资源敏感的场合，可以优先考虑
     Parallel Scavenge加Parallel OLd收集器
     
  6.CMS(Concurrent Mark Sweep)收集器：并发收集，低停顿
    CMS是一种以获取最短回收停段时间按为目标的收集器，并且给予"标记-清除"算法实现。运作过程分为4个步骤;
        初始标记：仅仅标记GC Roots能直接关联到的对象，速度很快。
        并发标记：进行GC Roots Tracing的过程
        重新标记：为了修正并发标记期间用户程序继续运作而导致标记变动的那一部分对象的标记记录
        并发清除：
     注：初始标记和重新标记需要"Stop The World"，并发表及和并发清楚和用户线程并行。
     CMS的缺点：
                1.CMS收集器堆CPU资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，
                总吞吐量降低。
                2.CMS收集器无法处理浮动垃圾，由于CMS并发清理阶段用户线程还在运行，所以还会有新的垃圾产生，这一部分垃圾出现在编译
                之后，CMS无法在当次收集中处理掉他们。这一部分垃圾被称为浮动垃圾。也是由于垃圾收集阶段用户线程还需运行，那也就还需
                预留有足够的空间内存给用户线程使用。
                3.空间碎片的产生
  
  
     
