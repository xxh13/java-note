HotSpot垃圾收集器分类
  注：直到现在为止，还没有最好的收集器出现，也没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。
  
  1. Serial收集器(JDK1.3之前的新生代收集器，单线程)
     Serial收集器在进行垃圾回收时，必须暂停其他的工作线程，直到收集结束。这项工作实际上是由虚拟机在后台自发动发起和自动完成的。
     到现在为止，Serial收集器是虚拟机运行在client模式下的默认新生代收集器。
     
  2. ParNew收集器
     ParNew收集器其实就是Serial收集器的多线程版本，和Serial收集器公用了相当多的代码。ParNew收集器是许多运行在Server模式下的虚拟机中首选
     的新生代收集器。只有PerNew收集器和Serial收集器能够和CMS收集器配合工作。
     
  3. Parallel Scavenge 收集器
     Parallel Scavenge收集器是一个新生代收集器，并且使用复制算法和多线程。主要目标是达到一个可控制的吞吐量(CPU运行用户代码的时间与
     CPU总消耗时间的比值)。Parallel Scavenge收集器提供2个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的参数直接设置
     吞吐量大小的参数。
     
  4. Serial Old 收集器
     Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程收集器，使用"标记-整理"算法，主要给Cilent模式下的虚拟机使用。
     如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK1.5之前的把嫩中与Parallel Scavenge收集器搭配使用，另一种用途
     是作为CMS收集器的后备预案。
  
  5. Parallel Old收集器
     Parallel Old是ParallelScavenge收集器的老年代版本，使用多线程和"标记-整理"算法。在注重吞吐量和CPU资源敏感的场合，可以优先考虑
     Parallel Scavenge加Parallel OLd收集器
     
  6.CMS(Concurrent Mark Sweep)收集器：并发收集，低停顿
    CMS是一种以获取最短回收停段时间按为目标的收集器，并且给予"标记-清除"算法实现。运作过程分为4个步骤;
        初始标记：仅仅标记GC Roots能直接关联到的对象，速度很快。
        并发标记：进行GC Roots Tracing的过程
        重新标记：为了修正并发标记期间用户程序继续运作而导致标记变动的那一部分对象的标记记录
        并发清除：
     注：初始标记和重新标记需要"Stop The World"，并发表及和并发清楚和用户线程并行。
     CMS的缺点：
                1.CMS收集器堆CPU资源非常敏感，在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程而导致应用程序变慢，
                总吞吐量降低。
                2.CMS收集器无法处理浮动垃圾，由于CMS并发清理阶段用户线程还在运行，所以还会有新的垃圾产生，这一部分垃圾出现在编译
                之后，CMS无法在当次收集中处理掉他们。这一部分垃圾被称为浮动垃圾。也是由于垃圾收集阶段用户线程还需运行，那也就还需
                预留有足够的空间内存给用户线程使用。
                3.空间碎片的产生
  
  7 G1(Garbage-First)收集器
    G1收集器是一款面向服务端应用的垃圾收集器。有着如下特点：
      1. 并行与并发：G1能充分利用多CPU，多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间。
      2. 分代收集：采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次GCd额就对象以获取更好的收集效果。
      3. 空间整合：从整体来看，G1是基于"标记-整理"算法的收集器，从局部看上是基于"复制"算法实现的。收集之后不会产生空间碎片。
      4. 可预测的停顿：可以建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾手机上的时间不得超过
         N毫秒
    G1收集器，java堆的内存布局和其他收集器有很大差别，他将整个java堆划分为多个大小相等的独立区域(Region)，新生代和老年代都是一部分region
    集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个java堆正进行全区域的垃圾手。G1跟踪各个Region里面垃圾
    堆积的价值大小(回收所获得的空间大小已经回收所需时间的经验值)，在后台维护一个优先列表，每次根据所允许的手机时间，优先回收回收价值最
    大的Region。
    在G1收集器中，虚拟机使用Remember Set来避免全堆扫描。G1中每个Region都会有一个与之对应的Remember Set，虚拟机发现程序在对Reference
    类型的数据进行写操作时，会产生一个暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关
    引用信息记录到引用对象所属的Region的Remember Set之中，当进行内存回收时，在GC根节点的枚举范围中加入Remember Set即可保证部队全栈
    扫描也不会有遗漏。
    G1收集器运作步骤：
                      1. 初始标记
                      2. 并发标记
                      3. 最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记，虚拟机将这段时间对象的变化
                                   记录在线程Remember Set Logs里面，最终标记阶段需要把Remember Set Logs的数据合并到Remember Set中。
                      4. 筛选回收
  
     
